---
layout:     post
title:      Maven-自动化构建工具
subtitle:   
date:       2021-03-23
author:     Hao
header-img: img/post/post_bg_coffee.jpg
catalog: true
mathjax: true
tags:
    - Maven
---

## Introducing Maven

当前技术开发过程中存在以下问题：

1. 一个项目就是一个工程。如果项目庞大，就不再适合用 package 划分，最好是每个模块一个工程，这样独立开来利于分工协作。借助 Maven，我们可以把一个工程划分为多个模块子项目。

2. 项目 jar 包需要手动复制，浪费存储空间，并且项目显得臃肿。借助 Maven，只需引用 Maven 仓库中的 jar 包坐标，而非手动复制。

3. jar 包要别人准备好，或去各自官网下载。不同网站提供的 jar 包形式不同，且有些网站就是以 Maven 形式提供。借助 Maven，我们以统一规范的方式下载。

4. 一个 jar 包依赖的其他 jar 包需全部手动导入，费时费力且易出错。引入 Maven 可以自动导入向上依赖的 jar 包。

## What is Maven

Maven 是 Java 平台的自动化构建工具。构建工具主要经历了 Make —> Ant —> Maven —> Gradle 的演变过程。构建是指以 Java 源文件、配置文件等资源为材料，生成可运行项目的过程。主要完成编译、打包、部署、测试等环节。Maven 的主要功能有：

1. 提供了一套标准化的项目结构；
2. 提供了一套标准化的构建流程 (编译，测试，打包，发布)；
3. 提供了一套依赖管理机制；

## Install Maven

1. 确保已安装 JDK，可参考[这篇文章](https://haozhangms.github.io/2020/12/08/Windows-%E4%B8%8B-JDK-%E5%AE%89%E8%A3%85%E4%B8%8E%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/)；
2. 在官网下载解压缩 Maven，官网地址在[这里](https://maven.apache.org/)；
3. 配置环境变量 *MAVEN_HOME*、*Path*如下，Window系统在系统环境变量中配置，Mac系统在用户根目录的 .bash_profile 或 .zshrc 配置文件中配置；

```
export M2_HOME=/usr/local/apache-maven-3.6.3
export PATH=$PATH:$M2_HOME/bin
```

4. *mvn -v* 命令查看 Maven 版本，验证是否安装成功；

```
$ mvn -v                        
Apache Maven 3.6.3 (cecedd343002696d0abb50b32b541b8a6ba2883f)
Maven home: /usr/local/apache-maven-3.6.3
....
```

## Maven 核心概念

### 约定的目录结构
方便 Maven 构建时查找源文件 (注意：约定 > 配置 > 编码)

```
Hello
—— pom.xml
—— src
   —— main
       —— java
       —— resources
   —— test
       —— java
       —— resources
```

### POM
Maven 配置核心文件，即上面的 pom.xml

### 坐标

Maven 使用 GroupId (组织名)、ArtifactId (jar包名)、Version (jar包版本) 唯一定位一个依赖

```
<dependency>
    <groupId>commons-logging</groupId>
    <artifactId>commons-logging</artifactId>
    <version>1.2</version>
</dependency>
```

### 依赖管理
Maven 解决了依赖管理的问题。例如，项目依赖 *abc.jar* 包，而 *abc.jar* 又依赖 *xyz.jar* 包。

![img](/img/post/Maven/post_dependency.png)

当我们声明了 *abc.jar* 包的依赖时，Maven自动把*abc.jar* 和依赖的 *xyz.jar* 都加入了我们的项目依赖，不需要我们自己去研究 *xyz.jar* 是否需要依赖 *xyz.jar*。

### 仓库：本地仓库/镜像仓库/中央仓库

![img](/img/post/Maven/post_repo.png)

本地仓库存储我们已下载的jar包；\
中央仓库是 Maven 提供的官方仓库，我们可以从中央仓库下载依赖到本地仓库；\
如果国内访问速度较慢，可以选择镜像仓库，镜像仓库定期同步中央仓库。国内用户可以使用阿里云提供的Maven镜像仓库，在 *.m2* 目录的 *settings.xml* 文件中添加如下设置。

```
<settings>
    <mirrors>
        <mirror>
            <id>aliyun</id>
            <name>aliyun</name>
            <mirrorOf>central</mirrorOf>
            <!-- 国内推荐阿里云的Maven镜像 -->
            <url>https://maven.aliyun.com/repository/central</url>
        </mirror>
    </mirrors>
</settings>
```

### 生命周期
即 Maven 构建的流程顺序。生命周期由一系列阶段 (phase) 构成，以内置的生命周期*default* 为例，它包含以下 phase：

* validate 
* initialize
* generate-sources
* process-sources
* generate-resources
* process-resources
* compile
* process-classes
* generate-test-sources
* process-test-sources
* generate-test-resources
* process-test-resources
* test-compile
* process-test-classes
* test
* prepare-package
* package
* pre-integration-test
* integration-test
* post-integration-test
* verify
* install
* deploy

如果我们运行 *mvn package*，Maven 就执行 *default* 生命周期，从开始 *validate* phase 一直运行到 *package* 这个 phase。

如果我们运行 *mvn compile*，Maven 也会执行 *default* 生命周期，但这次它只会从 *validate* phase 运行到 *compile* phase。

另一个常用的生命周期是 *clean*，它会执行 *pre-clean*、*clean*、*post-clean* 三个 phase。

所以我们使用 *mvn* 命令时，后面的参数是 phase，Maven 会根据生命周期自动运行到指定的 phase。

更复杂一点，我们指定多个 phase。例如，运行 *mvn clean package*，Maven 先执行 *clean* 生命周期并运行到*clean* 这个 phase，然后执行 *default* 生命周期并运行到 *package* 这个phase

## 常用命令

实际开发中，经常使用的命令有：

+ *mvn clean*：清理所有生成的class和jar；
+ *mvn clean compile*：先清理，再执行到 *compile*；
+ *mvn clean test*：先清理，再执行到 *test*，因为执行 *test* 前必须执行 *compile*，所以不必指定*compile*；
+ *mvn clean package*：先清理，再执行到 *package*；

## 模块管理

在软件开发中，把一个大项目分拆为多个模块是降低软件复杂度的有效方法：

![img](/img/post/Maven/post_singleProj.png)

对于 Maven 来说，原来是一个大项目：

```
Single Project
—— pom.xml
—— src
```

现在可以拆分为 3 个模块：

```
Single Project
—— Module-a
   —— pom.xml
   —— src
—— Module-b
   —— pom.xml
   —— src
—— Module-c
   —— pom.xml
   —— src
```

Maven可以有效地管理多个模块，我们只需要把每个模块当作一个独立的Maven项目，它们有各自独立的 pom.xml。例如，模块A的 pom.xml：

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.itranswarp.learnjava</groupId>
    <artifactId>module-a</artifactId>
    <version>1.0</version>
    <packaging>jar</packaging>

    <name>module-a</name>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
        <maven.compiler.source>11</maven.compiler.source>
        <maven.compiler.target>11</maven.compiler.target>
        <java.version>11</java.version>
    </properties>

    <!-- 以下三个依赖与模块B中相同 -->
    <dependencies>  
        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-api</artifactId>
            <version>1.7.28</version>
        </dependency>
        <dependency>
            <groupId>ch.qos.logback</groupId>
            <artifactId>logback-classic</artifactId>
            <version>1.2.3</version>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>org.junit.jupiter</groupId>
            <artifactId>junit-jupiter-engine</artifactId>
            <version>5.5.2</version>
            <scope>test</scope>
        </dependency>
    </dependencies>
</project>
```

模块B的 pom.xml：

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.itranswarp.learnjava</groupId>
    <artifactId>module-b</artifactId>
    <version>1.0</version>
    <packaging>jar</packaging>

    <name>module-b</name>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
        <maven.compiler.source>11</maven.compiler.source>
        <maven.compiler.target>11</maven.compiler.target>
        <java.version>11</java.version>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-api</artifactId>
            <version>1.7.28</version>
        </dependency>
        <dependency>
            <groupId>ch.qos.logback</groupId>
            <artifactId>logback-classic</artifactId>
            <version>1.2.3</version>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>org.junit.jupiter</groupId>
            <artifactId>junit-jupiter-engine</artifactId>
            <version>5.5.2</version>
            <scope>test</scope>
        </dependency>
    </dependencies>
</project>
```

可以看到，模块 A 和 B 的 pom.xml 高度相似。因此我们可以提取出共同的部分作为 parent：

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.itranswarp.learnjava</groupId>
    <artifactId>parent</artifactId>
    <version>1.0</version>
    <packaging>pom</packaging>

    <name>parent</name>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
        <maven.compiler.source>11</maven.compiler.source>
        <maven.compiler.target>11</maven.compiler.target>
        <java.version>11</java.version>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-api</artifactId>
            <version>1.7.28</version>
        </dependency>
        <dependency>
            <groupId>ch.qos.logback</groupId>
            <artifactId>logback-classic</artifactId>
            <version>1.2.3</version>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>org.junit.jupiter</groupId>
            <artifactId>junit-jupiter-engine</artifactId>
            <version>5.5.2</version>
            <scope>test</scope>
        </dependency>
    </dependencies>
</project>
```

注意到，parent 的 \<packaging\> 是 pom 不是 jar，因为 parent 本身不含任何Java代码。编写 parent 的 pom.xml 只是为了在各个模块中减少重复的配置。现在我们的整个工程结构如下：

```
Single Project
—— pom.xml
—— Parent
   —— pom.xml
—— Module-a
   —— pom.xml
   —— src
—— Module-b
   —— pom.xml
   —— src
—— Module-c
   —— pom.xml
   —— src
```

这样模块 A 就可以简化为：

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>com.itranswarp.learnjava</groupId>
        <artifactId>parent</artifactId>
        <version>1.0</version>
        <relativePath>../parent/pom.xml</relativePath>
    </parent>

    <artifactId>module-a</artifactId>
    <packaging>jar</packaging>
    <name>module-a</name>
</project>
```

模块B、模块C都可以直接从parent继承，大幅简化了pom.xml的编写。

如果模块A依赖模块B，则模块A需要模块B的jar包才能正常编译，我们需要在模块A中引入模块B：

```xml
...
<dependencies>
    <dependency>
        <groupId>com.itranswarp.learnjava</groupId>
        <artifactId>module-b</artifactId>
        <version>1.0</version>
    </dependency>
</dependencies>
```

最后，在编译的时候，需要在根目录创建一个pom.xml统一编译：

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">

    <modelVersion>4.0.0</modelVersion>
    <groupId>com.itranswarp.learnjava</groupId>
    <artifactId>build</artifactId>
    <version>1.0</version>
    <packaging>pom</packaging>
    <name>build</name>

    <modules>
        <module>parent</module>
        <module>module-a</module>
        <module>module-b</module>
        <module>module-c</module>
    </modules>
</project>
```

这样，在根目录执行mvn clean package时，Maven根据根目录的pom.xml找到包括parent在内的共4个\<module\>，一次性全部编译。


参考自：
1. [廖雪峰-Maven基础](https://www.liaoxuefeng.com/wiki/1252599548343744/1255945359327200)

2. [Maven Getting Started Guide](http://maven.apache.org/guides/getting-started/index.html)