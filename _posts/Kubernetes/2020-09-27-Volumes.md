---
layout:     post
title:      Chapter 9. Volumes
subtitle:   attaching disk storage to containers
date:       2020-09-27
author:     Hao
header-img: img/post/post_bg_coffee.jpg
catalog: true
mathjax: true
tags:
    - Kubernetes
---

在之前的几章中，我们学习了 Pod，Controllers 和 Service。这一章我们继续回到 Pod 内部，学习它的 containers 如何访问和互相共享外部存储。

我们可以把 Pod 看作一个逻辑上的 host，运行在其中的进程（即 containers）共享 CPU、RAM、网络接口等其他资源。但文件系统并非如此，Pod 中的每个 container 都有自己的文件系统，因为 containers 的文件系统来自于构建它的 image。所以即便是运行在相同 Pod 的 containers，它们之间也不能互相看到对方的文件系统。

但在某种场景下，我们想让新创建的 container 可以从上一个完成的地方继续运行。Kubernetes 通过定义了 *Volumens* 来提供这项功能。Volumes 不是 Kubernetes 中最上层的资源对象，它可以被认为是 Pod 的一部分，依附于 Pod 存在，与 Pod 有相同的生命周期。这就意味着，Pod 创建时 Volume 也被创建，Pod 销毁时 Volume 也被销毁。因此，Volume 中的内容可以在多个 containers 的生命周期中存在。一个新创建的 container 可以看到上一个 container 写入该 Volume 的文件。

### Introducing volumes

作为 Pod 的一部分，Volume 不能被单独创建，它只能在 Pod 的描述文件中被创建，这有点像 container。一个 Volume 只要被这个 Pod 中的 containers 挂载，它就可以被这些挂载的 containers 访问到。

#### Explaining Volumes with an exmaple

举个例子来解释 Volume。假设我们有一个 Pod，其中运行着三个 containers，如下图所示。一个 ContentAgent 容器用来创建 HTML 页面，并把它保存在 */var/html* 文件夹；一个 WebServer 容器用来将 *var/htdocs* 文件夹下的 HTML 页面生成 web 服务器，并把访问的日志保存在 */var/logs* 文件夹。还有一个 logRotator 容器用来分析处理 */var/logs* 目录下的日志。

![img](/img/post/post_volume_exm.png)

每个 container 都有简单清楚的任务。正常情况下，这样的 Pod 没有任何意义，因为 ContentAgent 容器创建的 HTML 页面，WebServer 容器访问不到；WebServer 容器保存的访问日志 logRotator 容器也访问不到。

但当我们给这个 Pod 添加两个 Volumes，并把它们合适地挂载在三个 containers 上，三个容器就可以一起工作。首先，我们创建一个 publicHtml Volume，它被同时挂载在 ContentAgent 容器的 */var/html* 和 WebServer 容器的 *var/htdocs* 目录。WebServer 就可以访问到 ContentAgent 容器生成的 HTML 页面了。

同样地，创建一个 logVol Volume，挂载在 WEbServer 容器的 */var/logs* 目录和 logRotator 容器的 */var/logs* 目录，这样 logRorator 容器就可以访问到 WebServer 生成的访问日志了。

#### Introducing Volume types

官方提供了很多种 Volume 类型。一些是常用的，其他是针对于特定的存储技术。在上面的例子中，初始情况下两个 Volume 都是空的，所以可以使用 emptyDir 类型的 Volume。一共有以下类型：

+ emptyDir：空目录，用于存放临时数据；
+ hostPath：把 Worker Node 的文件系统的目录挂载到 Pod 中；
+ gitRepo：通过 Git 仓库内容来初始化的 Volume；
+ nfs：An NFS share mounted into the pod；
+ gcePersistentDisk(Google Compute Engine), awsElasticBlockStore(AWS), azureDisk(Azure)：挂载云提供商的特定存储；
+ cinder, cephfs, iscsi, flocker, glusterfs, quobyte, rbd, flexVolume, vsphere- Volume, photonPersistentDisk, scaleIO：挂载其他类型的网络存储；
+ configMap, secret, sownloadAPI：给 Pod 暴露某些资源信息的特定类型；
+ persistentVolumeClaim：A way to use a pre- or dynamically provisioned per- sistent storage；

有很多类型笔者也不是很清楚。这些类型都是服务于不同的目的。一个 Pod 可以同时有多个不同类型的 Volume。

### 使用 Volume 在 container 之间共享数据

我们先学习如何在一个 Pod 中的多个 containers 之间共享数据。

#### Using an emptyDir Volume

emptyDir 是最简单的 Volume 类型，它被初始化为一个空目录，然后运行在 Pod 中的 container 向其中写数据。emptyDir 在 containers 之间共享数据时非常有用。我们还是以上面介绍的例子，不过我们只关注 contentAgent 和 webServer 两个 containers。

我们使用 *Nginx* 作为 web server，用 UNIX *fortune* 命令来生成 HTML 页面，*fortune* 命令每次会随机打印出一串字符。我们写一个脚本每十秒调用一次 *fortunr* 命令。Nginx 镜像和 fortune 镜像都已经准备在 DockerHub 上了。下面我们就创建这个 Pod。

```yml
apiVersion: v1
kind: Pod
metadata:
  name: fortune
spec:
  containers:   # fortune镜像创建html-generator容器
  - image: luksa/fortune 
    name: html-generator 
    volumeMounts:   # html Volume挂载/var/htdocs目录
    - name: html
      mountPath: /var/htdocs
  - image: nginx:alpine   # nginx镜像创建web-server容器
    name: web-server 
    volumeMounts:   # html Volume同样挂载在/usr/share/nginx/html目录
    - name: html
      mountPath: /usr/share/nginx/html
      readOnly: true    # 设置为只读
    ports:
    - containerPort: 80 
      protocol: TCP
  volumes:      # 这里创建Volume
  - name: html
    emptyDir: {}
```

上面的 Pod 包含两个 containers 和一个 Volume。当 html-generator 容器开始工作时，它把 *fortune* 的输出写到 */var/htdocs/index.html*。因为该目录被挂载在 Volume，所以 index.html 文件被写到 Volume 上。当 web-server 容器开始工作时，它就以 /usr/share/nginx/html 目录（这是 Nginx 的默认目录）下的文件生成 web server，因为已经把 Volume 挂载到这个目录，Nginx 就以 html-generator 容器写的 index.html 文件生成 web server，并监听 Pod 的 80 端口。所以当 client 向 Pod 的 80 端口发送 HTTP 请求时，将收到 *fortune* 信息作为响应。

为了看到 *fortune* 响应，我们把 Pod 的端口映射到本机端口。

```
$ kubectl port-forward fortune 8080:80
Forwarding from 127.0.0.1:8080 -> 80
Forwarding from [::1]:8080 -> 80
```

然后访问本机的 8080 端口。可以看到该 Pod 在正常工作。

```
$ curl http://localhost:8080
Beware of a tall blond man with one black shoe.
```

emptyDir 类型的 Volume 是被创建在运行该 Pod 的 Worker Node 的磁盘上，所以它的性能依赖于磁盘的性能。你也可以通过以下描述告诉 Kubernetes 创建一个内存上的 emptyDir。

```
volumes:      
- name: html
  emptyDir: {}
    medium: Memory
```

#### Using a Git Repository

gitRepo Volume 是一个用 clone 的 git 仓库填充的 emptyDir Volume，如下图所示。

![img](/img/post/post_gitrepo.png)

注意：在 gitRepo Volume 被创建之后，它就不会再和 Git 仓库保持同步了。当你往仓库中 push 提交之后，Volume 的内容不会更新。然而，如果 Pod 通过 RC 管理，删除 Pod 可以使 RC 新创建 Pod，同时 pull Git 仓库的内容创建 Volume。这时新创建的 Volume 会包含最新的内容。

可以使用一个 Git 仓库存储静态的 HTML 页面，然后创建一个 Pod 包含一个 Web Server container 和一个 gitRepo Volume。每次 Pod 被创建时，都会 pull 最新的 HTML 页面。接下来我们将实现这个示例。

已经有一个 HTML 文件的 Git 仓库 *https://github.com/luksa/kubia-website-example.git*，只需要 fork 到自己的账户下即可。然后就像之前一样创建一个 Pod，只不过现在这个 Pod 包含一个 Web Server 容器和一个 gitRepo Volume。gitRepo 指向自己 fork 的 git 仓库。

```yml
apiVersion: v1
kind: Pod
metadata:
  name: gitrepo-volume-pod 
spec:
  containers:
    - image: nginx:alpine
      name: web-server 
      volumeMounts:
        - name: html
          mountPath: /usr/share/nginx/html
          readOnly: true
      ports:
      - containerPort: 80 
        protocol: TCP
  volumes:
    - name: html
      gitRepo:  # 在创建一个gitRepo Volume
        repository: https://github.com/haozhangms/  kubia-website-example   # Volume将clone这个仓库 
        revision: master    # 检索master分支
        directory: .    # 仓库被clone到Volume的根目录
```

当创建 Pod 时，Volume 先被初始化为空目录，然后指向的 Git 仓库 clone 进去。另外，我们也要指定目录为 .（当前目录），否则仓库会被 clone 到 Volume 的子目录中；还要记得指定仓库的哪一个分支。

当 Pod 正常运行后，就可以通过 Port forwarding 验证 Pod 了。

和 emptyDir 一样，gtiRepo Volume是一个 Pod 特定的目录，当 Pod 消亡时 Volume 也会消亡。然而其他类型的 Volume 不会创建一个新目录，而是挂载一个已有的外部目录到 Pod 的容器的文件系统上。这种 Volume 的内容就不会随 Pod 消亡而消亡，可以存活多个 Pod 的生命周期。接下来我们将学习。

### 访问 Worker Node 文件系统上的文件

大多数 Pod 都不会和 host Node 交互，所以不应该访问 Node 上的文件系统。但是某些系统级的 Pod（通常由 DaemonSet 管理）确实需要读取 Node 上的文件或使用 Node 的文件系统。Kubernetes 因此提出了 hostPath 类型的 Volume。

#### Introducing the hostPath volume

一个 hostPath Volume 指向 host Node 文件系统的特定目录。运行在相同 Node 并且使用相同路径的 hostPath Volume 将看到相同的目录。如下图所示。

![img](/img/post/post_hostpath.png)

因为 emptyDir 和 gitRepo 的生命周期和 Pod 一样，而 hostPath Volume 的内容不会随 Pod 的消亡而消亡，所以 hostPath 是我们介绍的第一种持久存储。如果一个创建了 hostPath Volume 的 Pod 被删除了，下一个 Pod 的 hostPath Volume 指向了相同的路径，并且它被调度到了相同的 Node 上，那么它可以看到上一个 Pod 留下的数据。

但如果你想用 hostPath Volume 来保存数据库的数据，还请慎重。因为 hostPath Volume 的内容被保存在特定的 Node 上，如果 Pod 被迁移到其他 Node 上，它将看不到这些数据。

#### Examing system Pods that use hostPath Volume

我们看看 hostPath Volume 是如何被使用的。我们不用新创建 Pod，只需查看 *kube-system* 命名空间的 Pod。

```
$ kubectl get pod  --namespace kube-system 
NAME                               READY   STATUS    RESTARTS   AGE
coredns-f9fd979d6-g824g            1/1     Running   1          3d1h
etcd-minikube                      1/1     Running   1          3d1h
kube-apiserver-minikube            1/1     Running   1          3d1h
kube-controller-manager-minikube   1/1     Running   1          3d1h
kube-proxy-cspt2                   1/1     Running   1          3d1h
kube-scheduler-minikube            1/1     Running   1          3d1h
storage-provisioner                1/1     Running   5          3d1h
```

我们选择 *etcd-minikube* Pod 查看它的描述文件。可以看到，这个 Pod 使用了两个 hostPath Volume，分别访问两个目录。

```
....
Volumes:
  etcd-certs:
    Type:          HostPath (bare host directory volume)
    Path:          /var/lib/minikube/certs/etcd
    HostPathType:  DirectoryOrCreate
  etcd-data:
    Type:          HostPath (bare host directory volume)
    Path:          /var/lib/minikube/etcd
    HostPathType:  DirectoryOrCreate
....
```

hostPath Volume 主要用来访问 Node 的数据。当然它也可以尝试用来在单节点集群上持久存储，比如 Minikube。之后我们将介绍在集群中（不管单节点还是多节点）持久存储的方法。

### Using persistent storage


参考自：
1. 《Kuberneter in Action》 by Marko Luksa.

